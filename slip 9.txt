Q.1 Write a program to create a child process using fork().The parent should goto sleep state and 
child process should begin its execution. In the child process, use execl() to execute the “ls” 
command. 

#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>

int main() {
    pid_t pid = fork();

    if (pid < 0) {
        printf("Fork failed\n");
        return 1;
    }

    if (pid == 0) {
        execl("/bin/ls", "ls", "-l", NULL);
        printf("execl failed\n");
        return 1;
    } else {
        printf("Parent PID: %d, going to sleep...\n", getpid());
        sleep(10);
        printf("Parent woke up\n");
    }

    return 0;
}


Partially implement the Menu driven Banker's algorithm for accepting Allocation, Max from 
user. 
a) Accept Available 
b) Display Allocation, Max 
c) Find Need and display It, 
d) Display Available Consider the system with 3 resources types A,B, and C with 7,2,6 
instances respectively. 
Consider the following snapshot: 
 
 
Answer the following questions: 
a) Display the contents of Available array? 
b) Is there any deadlock? Print the message



#include <stdio.h>
#include <stdbool.h>

#define P 5 // Number of processes
#define R 3 // Number of resources

void displayMatrix(int mat[P][R], char name[]) {
    printf("%s Matrix:\n", name);
    for(int i=0;i<P;i++){
        for(int j=0;j<R;j++)
            printf("%d ", mat[i][j]);
        printf("\n");
    }
}

void calculateNeed(int need[P][R], int max[P][R], int alloc[P][R]){
    for(int i=0;i<P;i++)
        for(int j=0;j<R;j++)
            need[i][j] = max[i][j] - alloc[i][j];
}

bool isSafe(int alloc[P][R], int max[P][R], int avail[R]){
    int need[P][R];
    calculateNeed(need,max,alloc);
    bool finish[P] = {false};
    int work[R];
    for(int i=0;i<R;i++) work[i] = avail[i];
    int count = 0;

    while(count < P){
        bool found = false;
        for(int p=0;p<P;p++){
            if(!finish[p]){
                int j;
                for(j=0;j<R;j++)
                    if(need[p][j] > work[j]) break;
                if(j==R){
                    for(int k=0;k<R;k++) work[k]+=alloc[p][k];
                    finish[p] = true;
                    count++;
                    found = true;
                }
            }
        }
        if(!found) break;
    }

    return (count == P);
}

int main(){
    int alloc[P][R], max[P][R];
    int total[R] = {7,2,6};
    int avail[R];

    printf("Enter Allocation Matrix:\n");
    for(int i=0;i<P;i++)
        for(int j=0;j<R;j++)
            scanf("%d",&alloc[i][j]);

    printf("Enter Maximum Matrix:\n");
    for(int i=0;i<P;i++)
        for(int j=0;j<R;j++)
            scanf("%d",&max[i][j]);

    // Display matrices
    displayMatrix(alloc,"Allocation");
    displayMatrix(max,"Maximum");

    // Calculate Available
    for(int j=0;j<R;j++){
        int sum = 0;
        for(int i=0;i<P;i++) sum += alloc[i][j];
        avail[j] = total[j] - sum;
    }

    printf("\nAvailable Array: ");
    for(int j=0;j<R;j++) printf("%d ", avail[j]);
    printf("\n");

    if(isSafe(alloc,max,avail))
        printf("System is in SAFE state. No deadlock.\n");
    else
        printf("System is NOT in safe state. Deadlock possible!\n");

    return 0;
}


or


Q.2 Write the program to simulate Round Robin (RR) scheduling. The arrival time and first CPU- 
burst for different n number of processes should be input to the algorithm. Also give the time 
quantum as input. Assume the fixed IO waiting time (2 units). The next CPU-burst should be 
generated randomly. The output should give Gantt chart, turnaround time and waiting time for each 
process. Also find the average waiting time and turnaround time. 

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define IO_WAIT 2

typedef struct {
    int pid;
    int arrival;
    int burst;
    int remaining;
    int completion;
    int turnaround;
    int waiting;
} Process;

int main() {
    int n, timeQuantum, completed = 0, currentTime = 0;
    float totalTAT = 0, totalWT = 0;
    srand(time(NULL));

    printf("Enter number of processes: ");
    scanf("%d", &n);

    Process p[n];
    for (int i = 0; i < n; i++) {
        p[i].pid = i + 1;
        printf("Enter arrival time of P%d: ", i + 1);
        scanf("%d", &p[i].arrival);
        printf("Enter first CPU burst of P%d: ", i + 1);
        scanf("%d", &p[i].burst);
        p[i].remaining = p[i].burst;
    }

    printf("Enter Time Quantum: ");
    scanf("%d", &timeQuantum);

    printf("\nGantt Chart:\n");
    while (completed < n) {
        int doneInThisCycle = 0;
        for (int i = 0; i < n; i++) {
            if (p[i].remaining > 0 && p[i].arrival <= currentTime) {
                int execTime = (p[i].remaining < timeQuantum) ? p[i].remaining : timeQuantum;
                printf("| P%d (%d-%d) ", p[i].pid, currentTime, currentTime + execTime);
                currentTime += execTime;
                p[i].remaining -= execTime;

                if (p[i].remaining == 0) {
                    currentTime += IO_WAIT + (rand() % 10 + 1); // IO wait + next random burst
                    p[i].completion = currentTime;
                    p[i].turnaround = p[i].completion - p[i].arrival;
                    p[i].waiting = p[i].turnaround - p[i].burst;
                    totalTAT += p[i].turnaround;
                    totalWT += p[i].waiting;
                    completed++;
                }
                doneInThisCycle = 1;
            }
        }
        if (!doneInThisCycle) {
            currentTime++;
        }
    }
    printf("|\n\n");

    printf("Process\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\n");
    for (int i = 0; i < n; i++) {
        printf("P%d\t%d\t%d\t%d\t\t%d\t\t%d\n", p[i].pid, p[i].arrival, p[i].burst,
               p[i].completion, p[i].turnaround, p[i].waiting);
    }

    printf("\nAverage Turnaround Time: %.2f\n", totalTAT / n);
    printf("Average Waiting Time: %.2f\n", totalWT / n);

    return 0;
}

