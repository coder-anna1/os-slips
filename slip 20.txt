Q.1 Write a program to create a child process using fork().The parent should goto sleep state and 
child process should begin its execution. In the child process, use execl() to execute the “ls” 
command. 


ans
#include<stdio.h>
#include<unistd.h>
#include<stdlib.h>

int main(){
    pid_t pid=fork();

    if(pid<0){
        printf("Fork failed\n");
        return 1;
    }
    else if(pid==0){
        execl("/bin/ls","ls","-l",NULL);
        printf("execl failed\n");
        exit(1);
    }
    else{
        printf("Parent process going to sleep\n");
        sleep(5);
        printf("Parent process awake\n");
    }
    return 0;
}



Q.2 Write the simulation program to implement demand paging and show the page scheduling 
and total number of page faults for the following given page reference string. Give input n=3 as 
the number of memory frames. 
Reference String : 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2 
i. Implement LRU


ans
#include <stdio.h>
#define MAX 100

int findLRU(int time[], int n) {
    int i, minimum = time[0], pos = 0;
    for(i = 1; i < n; ++i) {
        if(time[i] < minimum) {
            minimum = time[i];
            pos = i;
        }
    }
    return pos;
}

int main() {
    int frames[MAX], time[MAX];
    int referenceString[MAX];
    int n, refLen;
    int i, j, pos, pageFaults = 0, count = 0, found;

    printf("Enter number of memory frames: ");
    scanf("%d", &n);
    printf("Enter the length of the reference string: ");
    scanf("%d", &refLen);
    printf("Enter the reference string:\n");
    for(i = 0; i < refLen; i++) {
        scanf("%d", &referenceString[i]);
    }

    for(i = 0; i < n; ++i) {
        frames[i] = -1;
        time[i] = 0;
    }

    printf("\nPage Replacement Process (LRU):\n");

    for(i = 0; i < refLen; ++i) {
        found = 0;
        for(j = 0; j < n; ++j) {
            if(frames[j] == referenceString[i]) {
                count++;
                time[j] = count;
                found = 1;
                break;
            }
        }

        if(!found) {
            for(j = 0; j < n; ++j) {
                if(frames[j] == -1) {
                    count++;
                    pageFaults++;
                    frames[j] = referenceString[i];
                    time[j] = count;
                    found = 1;
                    break;
                }
            }
        }

        if(!found) {
            pos = findLRU(time, n);
            count++;
            pageFaults++;
            frames[pos] = referenceString[i];
            time[pos] = count;
        }

        printf("Step %2d: ", i + 1);
        for(j = 0; j < n; ++j) {
            if(frames[j] != -1)
                printf("%d ", frames[j]);
            else
                printf("- ");
        }

        if(found)
            printf(" <- No Page Fault\n");
        else
            printf(" <- Page Fault\n");
    }

    printf("\nTotal Page Faults = %d\n", pageFaults);
    return 0;
}



        or


Write the simulation program using FCFS. The arrival time and first CPU bursts of different jobs 
should be input to the system. Assume the fixed I/O waiting time (2 units). The next CPU burst 
should be generated using random function. The output should give the Gantt chart, Turnaround 
Time and Waiting time for each process and average times.


ans
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

typedef struct {
    char name[3];
    int at;
    int bt;
    int ct;
    int tat;
    int wt;
    int tbt;
} Process;

int main() {
    int n;
    int currentTime = 0;
    float totalWT = 0, totalTAT = 0;
    const int IO_WAIT = 2;

    printf("Enter number of processes: ");
    scanf("%d", &n);

    Process p[n];
    srand(time(NULL));

    for(int i = 0; i < n; i++) {
        snprintf(p[i].name, sizeof(p[i].name), "P%d", i+1);
        printf("Enter arrival time for %s: ", p[i].name);
        scanf("%d", &p[i].at);
        printf("Enter first CPU burst for %s: ", p[i].name);
        scanf("%d", &p[i].bt);
        p[i].tbt = p[i].bt;
        p[i].wt = 0;
        p[i].tat = 0;
    }

    printf("\nGantt Chart:\n|");
    for(int i = 0; i < n; i++) {
        if(currentTime < p[i].at)
            currentTime = p[i].at;
        printf("%d|", currentTime);
        p[i].wt = currentTime - p[i].at;
        currentTime += p[i].tbt;
        p[i].ct = currentTime;
        currentTime += IO_WAIT;
        int nextBurst = (rand() % 10) + 1;
        currentTime += nextBurst;
        printf("%d|", currentTime);
        p[i].tat = p[i].ct - p[i].at + nextBurst + IO_WAIT;
        totalWT += p[i].wt;
        totalTAT += p[i].tat;
    }

    printf("\n\nProcess\tAT\tBT\tCT\tTAT\tWT\n");
    for(int i = 0; i < n; i++) {
        printf("%s\t%d\t%d\t%d\t%d\t%d\n",
               p[i].name, p[i].at, p[i].bt, p[i].ct, p[i].tat, p[i].wt);
    }

    printf("\nAverage Turnaround Time = %.2f\n", totalTAT / n);
    printf("Average Waiting Time = %.2f\n", totalWT / n);

    return 0;
}
