Q.1 Create a child process using fork(), display parent and child process id. Child process will 
display the message “Hello World” and the parent process should display “Hi”. 


ans
#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>
#include <sys/wait.h>

int main() {
pid_t p;
printf("Before Fork\n");
p = fork();

if (p < 0) {
printf("Fork failed.\n");
return 1;
} else if (p == 0) {
printf("Hello World\n");
printf("I am Child with ID: %d\n", getpid());
printf("My Parent ID is: %d\n", getppid());
} else {
wait(NULL);
printf("Hi\n");
printf("I am Parent with ID: %d\n", getpid());
printf("My Child's ID is: %d\n", p);
}
return 0;
}



Q.2 Write the simulation program to implement demand paging and show the page scheduling 
and total number of page faults for the following given page reference string. Give input n as the 
number of memory frames. 
Reference String: 0, 2, 1, 6, 4, 0, 1, 0, 3, 1, 2, 1 
 
Implement FIFO


ans
#include <stdio.h>

int main() {
int n, i, j, k, pageFaults = 0, flag;
int referenceString[] = {0, 2, 1, 6, 4, 0, 1, 0, 3, 1, 2, 1};
int length = sizeof(referenceString) / sizeof(referenceString[0]);

printf("Enter number of memory frames: ");
scanf("%d", &n);

int frames[n];
for(i = 0; i < n; i++) frames[i] = -1;

int index = 0; // FIFO index

printf("\nPage Reference String\tFrames\tPage Fault\n");
for(i = 0; i < length; i++) {
flag = 0;
for(j = 0; j < n; j++) {
if(frames[j] == referenceString[i]) {
flag = 1;
break;
}
}
if(flag == 0) { // Page fault
frames[index] = referenceString[i];
index = (index + 1) % n;
pageFaults++;
printf("%d\t\t\t", referenceString[i]);
for(k = 0; k < n; k++) {
if(frames[k] != -1)
printf("%d ", frames[k]);
else
printf("- ");
}
printf("\tYes\n");
} else {
printf("%d\t\t\t", referenceString[i]);
for(k = 0; k < n; k++) {
if(frames[k] != -1)
printf("%d ", frames[k]);
else
printf("- ");
}
printf("\tNo\n");
}
}

printf("\nTotal Page Faults: %d\n", pageFaults);
return 0;
}



    or


Consider the following graph 
 
The numbers written on edges represent the distance between the nodes. 
The numbers written on nodes represent the heuristic value. 
Implement A* algorithm in C/Python for above graph and find out most cost-effective path 
from A to J. 


ans
import heapq

class Node:
    def __init__(self, name, heuristic):
        self.name = name
        self.heuristic = heuristic
        self.edges = {}
        self.g = float('inf')
        self.f = float('inf')

    def add_edge(self, neighbor, cost):
        self.edges[neighbor] = cost

    def __lt__(self, other):
        return self.f < other.f

def a_star(start_node, goal_node):
    open_set = []
    start_node.g = 0
    start_node.f = start_node.heuristic
    heapq.heappush(open_set, start_node)
    came_from = {}
    visited = set()

    while open_set:
        current_node = heapq.heappop(open_set)
        if current_node in visited:
            continue
        visited.add(current_node)

        if current_node.name == goal_node.name:
            return reconstruct_path(came_from, current_node)

        for neighbor, cost in current_node.edges.items():
            tentative_g = current_node.g + cost
            if tentative_g < neighbor.g:
                came_from[neighbor] = current_node
                neighbor.g = tentative_g
                neighbor.f = neighbor.g + neighbor.heuristic
                heapq.heappush(open_set, neighbor)

    return None

def reconstruct_path(came_from, current_node):
    path = [current_node.name]
    while current_node in came_from:
        current_node = came_from[current_node]
        path.append(current_node.name)
    return path[::-1]

nodes = {
    'A': Node('A', 10),
    'B': Node('B', 8),
    'C': Node('C', 5),
    'D': Node('D', 7),
    'E': Node('E', 3),
    'F': Node('F', 6),
    'G': Node('G', 5),
    'H': Node('H', 3),
    'I': Node('I', 1),
    'J': Node('J', 1)
}

edges = [
    ('A','B',6), ('A','F',3),
    ('B','C',3), ('B','D',2),
    ('C','D',1), ('C','E',5),
    ('D','E',8),
    ('E','I',5), ('E','J',5),
    ('J','I',3),
    ('I','G',3), ('I','H',2),
    ('F','G',1), ('F','H',7)
]

for u,v,c in edges:
    nodes[u].add_edge(nodes[v], c)
    nodes[v].add_edge(nodes[u], c)

start_node = nodes['A']
goal_node = nodes['J']
path = a_star(start_node, goal_node)

if path:
    print("Cost-effective path from A to J:", " -> ".join(path))
else:
    print("No path found.")


.py extension