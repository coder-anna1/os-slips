Q.1 Write a program that demonstrates the use of nice () system call. After a child process is 
started using fork (), assign higher priority to the child using nice () system call. 

#include<stdio.h>
#include<unistd.h>
#include<sys/types.h>
#include<stdlib.h>

int main() {
    int pid, retnice;
    printf("Press Ctrl+Z to stop the process\n");
    pid = fork();
    for(;;) {
        if(pid == 0) {
            retnice = nice(-5);
            printf("Child gets higher CPU Priority %d \n", retnice);
            sleep(1);
        } else {
            retnice = nice(4);
            printf("Parent gets lower CPU Priority %d \n", retnice);
        }
    }
}


Q.2 Write the simulation program to implement demand paging and show the page scheduling 
and total number of page faults for the following given page reference string. Give input n as the 
number of memory frames. Reference String: 3, 4, 5, 6, 3, 4, 7, 3, 4, 5, 6, 7, 2, 4, 6 
i. Implement FIFO

#include <stdio.h>
#define MAX 100

int main() {
    int referenceString[MAX], frames[MAX], n, refLen;
    int i, j, k, pageFaults = 0, found, pos = 0;

    printf("Enter number of memory frames: ");
    scanf("%d", &n);
    printf("Enter the length of the reference string: ");
    scanf("%d", &refLen);
    printf("Enter the reference string (space-separated):\n");
    for(i = 0; i < refLen; i++) {
        scanf("%d", &referenceString[i]);
    }

    for(i = 0; i < n; i++) {
        frames[i] = -1;
    }

    printf("\nPage Replacement Process (FIFO):\n");
    for(i = 0; i < refLen; i++) {
        found = 0;
        for(j = 0; j < n; j++) {
            if(frames[j] == referenceString[i]) {
                found = 1;
                break;
            }
        }

        if(!found) {
            frames[pos] = referenceString[i];
            pos = (pos + 1) % n;
            pageFaults++;
            printf("Step %2d: ", i + 1);
            for(k = 0; k < n; k++) {
                if(frames[k] != -1)
                    printf("%d ", frames[k]);
                else
                    printf("- ");
            }
            printf(" <- Page Fault\n");
        } else {
            printf("Step %2d: ", i + 1);
            for(k = 0; k < n; k++) {
                if(frames[k] != -1)
                    printf("%d ", frames[k]);
                else
                    printf("- ");
            }
            printf(" <- No Page Fault\n");
        }
    }

    printf("\nTotal Page Faults = %d\n", pageFaults);
    return 0;
}


Q.2 partially implement the Menu driven Banker's algorithm for accepting Allocation, Max from 
user. 
a) Accept Available 
b) Display Allocation, Max 
c) Find Need and display It, 
d) Display Available Consider the system with 3 resources types A,B, and C with 7,2,6 instances 
respectively. 
Consider the following snapshot: 
 
Answer the following questions: 
a) Display the contents of Available array?

#include <stdio.h>
#include <stdbool.h>

int main() {
    int n, r = 3;
    printf("Enter number of processes: ");
    scanf("%d", &n);

    int Allocation[n][r], Max[n][r], Need[n][r];
    int Available[r];
    int i, j;
    int choice;

    for (i = 0; i < r; i++) {
        printf("Enter total instances of resource %c: ", 'A' + i);
        scanf("%d", &Available[i]);
    }

    while (1) {
        printf("\n--- Banker's Algorithm Menu ---\n");
        printf("1. Accept Allocation Matrix\n");
        printf("2. Accept Max Matrix\n");
        printf("3. Display Allocation and Max\n");
        printf("4. Find and Display Need Matrix\n");
        printf("5. Display Available\n");
        printf("6. Check Deadlock\n");
        printf("7. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                for (i = 0; i < n; i++) {
                    printf("Enter Allocation for process P%d: ", i);
                    for (j = 0; j < r; j++)
                        scanf("%d", &Allocation[i][j]);
                }
                break;

            case 2:
                for (i = 0; i < n; i++) {
                    printf("Enter Max for process P%d: ", i);
                    for (j = 0; j < r; j++)
                        scanf("%d", &Max[i][j]);
                }
                break;

            case 3:
                printf("\nAllocation Matrix:\n");
                for (i = 0; i < n; i++) {
                    for (j = 0; j < r; j++)
                        printf("%d ", Allocation[i][j]);
                    printf("\n");
                }
                printf("\nMax Matrix:\n");
                for (i = 0; i < n; i++) {
                    for (j = 0; j < r; j++)
                        printf("%d ", Max[i][j]);
                    printf("\n");
                }
                break;

            case 4:
                printf("\nNeed Matrix:\n");
                for (i = 0; i < n; i++) {
                    for (j = 0; j < r; j++) {
                        Need[i][j] = Max[i][j] - Allocation[i][j];
                        printf("%d ", Need[i][j]);
                    }
                    printf("\n");
                }
                break;

            case 5:
                printf("\nAvailable Resources: ");
                for (i = 0; i < r; i++)
                    printf("%d ", Available[i]);
                printf("\n");
                break;

            case 6: {
                bool finish[n];
                int work[r];
                for (i = 0; i < n; i++) finish[i] = false;
                for (i = 0; i < r; i++) work[i] = Available[i];

                bool deadlock = false;
                int count = 0;

                while (count < n) {
                    bool found = false;
                    for (i = 0; i < n; i++) {
                        if (!finish[i]) {
                            bool can_finish = true;
                            for (j = 0; j < r; j++) {
                                if (Need[i][j] > work[j]) {
                                    can_finish = false;
                                    break;
                                }
                            }
                            if (can_finish) {
                                for (j = 0; j < r; j++)
                                    work[j] += Allocation[i][j];
                                finish[i] = true;
                                found = true;
                                count++;
                            }
                        }
                    }
                    if (!found) {
                        deadlock = true;
                        break;
                    }
                }

                if (deadlock)
                    printf("\nDeadlock detected! Some processes cannot proceed.\n");
                else
                    printf("\nNo deadlock. All processes can complete.\n");
                break;
            }

            case 7:
                return 0;

            default:
                printf("Invalid choice\n");
        }
    }
    return 0;
}
