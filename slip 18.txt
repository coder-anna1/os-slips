Q. 1 Write a C program to accept the number of process and resources and find the need matrix 
content and display it.


ans
#include <stdio.h>

int main() {
    int process, resource, i, j;

    printf("Enter number of Processes: ");
    scanf("%d", &process);
    printf("Enter number of Resources: ");
    scanf("%d", &resource);

    int max[10][10], alloc[10][10], need[10][10];

    printf("\nEnter Max Matrix:\n");
    for(i = 0; i < process; i++) {
        for(j = 0; j < resource; j++) {
            scanf("%d", &max[i][j]);
        }
    }

    printf("\nEnter Allocation Matrix:\n");
    for(i = 0; i < process; i++) {
        for(j = 0; j < resource; j++) {
            scanf("%d", &alloc[i][j]);
        }
    }

    for(i = 0; i < process; i++) {
        for(j = 0; j < resource; j++) {
            need[i][j] = max[i][j] - alloc[i][j];
        }
    }

    printf("\nNeed Matrix:\n");
    for(i = 0; i < process; i++) {
        for(j = 0; j < resource; j++) {
            printf("%d\t", need[i][j]);
        }
        printf("\n");
    }

    return 0;
}



Q.2 Write the simulation program to implement demand paging and show the page scheduling 
and total number of page faults for the following given page reference string. Give input n as 
the number of memory frames. 
Reference String : 12,15,12,18,6,8,11,12,19,12,6,8,12,15,19,8 
Implement OPT 


ans
#include <stdio.h>
#define MAX 100
int predict(int referenceString[], int frames[], int refLen, int index, int n){
int i,j,farthest=index,pos=-1,found;
for(i=0;i<n;i++){
found=0;
for(j=index;j<refLen;j++){
if(frames[i]==referenceString[j]){
if(j>farthest){
farthest=j;
pos=i;
}
found=1;
break;
}
}
if(!found) return i;
}
return (pos==-1)?0:pos;
}
int main(){
int referenceString[MAX],frames[MAX];
int refLen=0,n=3;
int i,j,k,pageFaults=0,found;
printf("Enter the length of the reference string: ");
scanf("%d",&refLen);
printf("Enter the reference string (space-separated):\n");
for(i=0;i<refLen;i++){
scanf("%d",&referenceString[i]);
}
for(i=0;i<n;i++) frames[i]=-1;
printf("\nPage Replacement Process (OPT):\n");
for(i=0;i<refLen;i++){
found=0;
for(j=0;j<n;j++){
if(frames[j]==referenceString[i]){
found=1;
break;
}
}
if(!found){
int pos=-1;
for(j=0;j<n;j++){
if(frames[j]==-1){
pos=j;
break;
}
}
if(pos==-1) pos=predict(referenceString,frames,refLen,i+1,n);
frames[pos]=referenceString[i];
pageFaults++;
}
printf("Step %2d: ",i+1);
for(k=0;k<n;k++){
if(frames[k]!=-1) printf("%d ",frames[k]);
else printf("- ");
}
if(found) printf(" <- No Page Fault\n");
else printf(" <- Page Fault\n");
}
printf("\nTotal Page Faults = %d\n",pageFaults);
return 0;
}



       or


Write the simulation program using SJF (non-preemptive). The arrival time and first CPU bursts of 
different jobs should be input to the system. The Assume the fixed I/O waiting time (2 units).The next 
CPU burst should be generated using random function. The output should give the Gantt chart, 
Turnaround Time and Waiting time for each process and average times.   


ans
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

typedef struct {
char name[5];
int at;
int bt;
int tbt;
int ct;
int wt;
int tat;
} Process;

Process *p;
int n;
int currentTime = 0;
int completed = 0;
float totalWT = 0, totalTAT = 0;
const int IO_WAIT = 2;

void accept() {
printf("Enter number of processes: ");
scanf("%d", &n);
p = (Process*)malloc(sizeof(Process) * n);
for(int i=0;i<n;i++){
sprintf(p[i].name,"P%d",i+1);
printf("Enter arrival time for %s: ",p[i].name);
scanf("%d",&p[i].at);
printf("Enter CPU burst time for %s: ",p[i].name);
scanf("%d",&p[i].bt);
p[i].tbt = p[i].bt;
p[i].wt = 0;
p[i].tat = 0;
}
}

void sortByArrival() {
for(int i=0;i<n-1;i++){
for(int j=i+1;j<n;j++){
if(p[i].at > p[j].at){
Process temp = p[i];
p[i] = p[j];
p[j] = temp;
}
}
}
}

int getNextProcess() {
int idx=-1, minBT=9999;
for(int i=0;i<n;i++){
if(p[i].tbt>0 && p[i].at <= currentTime){
if(p[i].bt < minBT){
minBT = p[i].bt;
idx = i;
}
}
}
return idx;
}

void schedule() {
srand(time(NULL));
sortByArrival();
currentTime = p[0].at;
printf("\nGantt Chart:\n");
while(completed < n){
int idx = getNextProcess();
if(idx==-1){
printf("|%d|IDLE|%d|",currentTime,currentTime+1);
currentTime++;
} else {
printf("|%d|%s|%d|",currentTime,p[idx].name,currentTime+p[idx].bt);
p[idx].wt = currentTime - p[idx].at;
p[idx].tat = p[idx].wt + p[idx].bt;
currentTime += p[idx].bt;
p[idx].ct = currentTime;
totalWT += p[idx].wt;
totalTAT += p[idx].tat;
currentTime += IO_WAIT;
p[idx].tbt = 0;
completed++;
}
}
printf("\n");
}

void display() {
printf("\nProcess Details:\n");
printf("Name\tAT\tBT\tWT\tTAT\tCT\n");
for(int i=0;i<n;i++){
printf("%s\t%d\t%d\t%d\t%d\t%d\n",p[i].name,p[i].at,p[i].bt,p[i].wt,p[i].tat,p[i].ct);
}
printf("\nAverage WT: %.2f\n", totalWT/n);
printf("Average TAT: %.2f\n", totalTAT/n);
}

int main() {
accept();
schedule();
display();
return 0;
}
