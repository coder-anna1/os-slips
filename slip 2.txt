Q.1 Create a child process using fork(), display parent and child process id. Child process will 
display the message “Hello World” and the parent process should display “Hi”. 

#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>

int main() {
    pid_t p;
    printf("\nBefore Fork\n");
    p = fork();

    if (p == 0) {
        printf("\nHello World");
        printf("\nI am Child having id %d\n", getpid());
        printf("My Parent id is %d\n", getppid());
    } else if (p > 0) {
        printf("\nHi");
        printf("\nMy Child's id is %d\n", p);
        printf("I am Parent having id %d\n", getpid());
    } else {
        printf("\nFork failed!\n");
    }

    return 0;
}

Q.2 Write the simulation program using SJF (non-preemptive). The arrival time and first CPU 
bursts of different jobs should be input to the system. Assume the fixed I/O waiting time (2 units). 
The next CPU burst should be generated using random function. The output should give the Gantt 
chart,   Turnaround   Time   and   Waiting   time   for   each    process    and    average    times. [20 
marks] 


#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <limits.h>
#include <time.h>

#define MAX 50
#define IO_WAIT_TIME 2

void calculateTimes(int n, int arrival[], int burst[], int process[]) {
    int completion[MAX], turnaround[MAX], waiting[MAX];
    int current_time = 0, completed = 0;
    bool is_completed[MAX] = {false};
    float total_turnaround = 0, total_waiting = 0;

    printf("\nGantt Chart:\n");

    while (completed < n) {
        int idx = -1, min_burst = INT_MAX;
        for (int i = 0; i < n; i++) {
            if (arrival[i] <= current_time && !is_completed[i] && burst[i] < min_burst) {
                min_burst = burst[i];
                idx = i;
            }
        }
        if (idx != -1) {
            printf("| P%d (%d-%d) ", process[idx], current_time, current_time + burst[idx]);
            current_time += burst[idx];
            completion[idx] = current_time;
            turnaround[idx] = completion[idx] - arrival[idx];
            waiting[idx] = turnaround[idx] - burst[idx];
            total_turnaround += turnaround[idx];
            total_waiting += waiting[idx];
            is_completed[idx] = true;
            completed++;
            current_time += IO_WAIT_TIME + (rand() % 10 + 1);
        } else {
            current_time++;
        }
    }

    printf("|\n\nProcess\tAT\tBT\tCT\tTAT\tWT\n");
    for (int i = 0; i < n; i++) {
        printf("P%d\t%d\t%d\t%d\t%d\t%d\n", process[i], arrival[i], burst[i],
               completion[i], turnaround[i], waiting[i]);
    }
    printf("\nAverage Turnaround Time: %.2f", total_turnaround / n);
    printf("\nAverage Waiting Time: %.2f\n", total_waiting / n);
}

int main() {
    int n, arrival[MAX], burst[MAX], process[MAX];
    srand(time(0));
    printf("Enter number of processes: ");
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        process[i] = i + 1;
        printf("Enter arrival and burst time for process P%d: ", i + 1);
        scanf("%d %d", &arrival[i], &burst[i]);
    }
    calculateTimes(n, arrival, burst, process);
    return 0;
}
