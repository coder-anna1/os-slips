Q.1 Create a child process using fork(), display parent and child process id. Child process will 
display the message “Hello World” and the parent process should display “Hi”. 

#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>

int main() {
    pid_t p;
    printf("\nBefore Fork\n");
    p = fork();

    if (p == 0) {
        printf("\nHello World");
        printf("\nI am Child having id %d\n", getpid());
        printf("My Parent id is %d\n", getppid());
    } else if (p > 0) {
        printf("\nHi");
        printf("\nMy Child's id is %d\n", p);
        printf("I am Parent having id %d\n", getpid());
    } else {
        printf("\nFork failed!\n");
    }

    return 0;
}

Q.2 Write the simulation program using SJF (non-preemptive). The arrival time and first CPU 
bursts of different jobs should be input to the system. Assume the fixed I/O waiting time (2 units). 
The next CPU burst should be generated using random function. The output should give the Gantt 
chart,   Turnaround   Time   and   Waiting   time   for   each    process    and    average    times. [20 
marks] 


#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <limits.h>
#include <time.h>

#define MAX 50
#define IO_WAIT_TIME 2

void calculateTimes(int n, int arrival[], int burst[], int process[]) {
    int completion[MAX], turnaround[MAX], waiting[MAX];
    int current_time = 0, completed = 0;
    bool is_completed[MAX] = {false};
    float total_turnaround = 0, total_waiting = 0;

    printf("\nGantt Chart:\n");

    while (completed < n) {
        int idx = -1, min_burst = INT_MAX;
        for (int i = 0; i < n; i++) {
            if (arrival[i] <= current_time && !is_completed[i] && burst[i] < min_burst) {
                min_burst = burst[i];
                idx = i;
            }
        }
        if (idx != -1) {
            printf("| P%d (%d-%d) ", process[idx], current_time, current_time + burst[idx]);
            current_time += burst[idx];
            completion[idx] = current_time;
            turnaround[idx] = completion[idx] - arrival[idx];
            waiting[idx] = turnaround[idx] - burst[idx];
            total_turnaround += turnaround[idx];
            total_waiting += waiting[idx];
            is_completed[idx] = true;
            completed++;
            current_time += IO_WAIT_TIME + (rand() % 10 + 1);
        } else {
            current_time++;
        }
    }

    printf("|\n\nProcess\tAT\tBT\tCT\tTAT\tWT\n");
    for (int i = 0; i < n; i++) {
        printf("P%d\t%d\t%d\t%d\t%d\t%d\n", process[i], arrival[i], burst[i],
               completion[i], turnaround[i], waiting[i]);
    }
    printf("\nAverage Turnaround Time: %.2f", total_turnaround / n);
    printf("\nAverage Waiting Time: %.2f\n", total_waiting / n);
}

int main() {
    int n, arrival[MAX], burst[MAX], process[MAX];
    srand(time(0));
    printf("Enter number of processes: ");
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        process[i] = i + 1;
        printf("Enter arrival and burst time for process P%d: ", i + 1);
        scanf("%d %d", &arrival[i], &burst[i]);
    }
    calculateTimes(n, arrival, burst, process);
    return 0;
}


or

Partially implement the Menu driven Banker's algorithm for accepting Allocation, Max from 
user. 
a) Accept Available 
b) Display Allocation, Max 
c) Find Need and display It, 
d) Display Available Consider the system with 3 resources types A,B, and C with 7,2,6 
instances respectively. 
Consider the following snapshot: 
 
 
Answer the following questions: 
a) Display the contents of Available array? 
b) Is there any deadlock? Print the message



#include <stdio.h>
#include <stdbool.h>

#define P 5 // Number of processes
#define R 3 // Number of resources

void displayMatrix(int mat[P][R], char name[]) {
    printf("%s Matrix:\n", name);
    for(int i=0;i<P;i++){
        for(int j=0;j<R;j++)
            printf("%d ", mat[i][j]);
        printf("\n");
    }
}

void calculateNeed(int need[P][R], int max[P][R], int alloc[P][R]){
    for(int i=0;i<P;i++)
        for(int j=0;j<R;j++)
            need[i][j] = max[i][j] - alloc[i][j];
}

bool isSafe(int alloc[P][R], int max[P][R], int avail[R]){
    int need[P][R];
    calculateNeed(need,max,alloc);
    bool finish[P] = {false};
    int work[R];
    for(int i=0;i<R;i++) work[i] = avail[i];
    int count = 0;

    while(count < P){
        bool found = false;
        for(int p=0;p<P;p++){
            if(!finish[p]){
                int j;
                for(j=0;j<R;j++)
                    if(need[p][j] > work[j]) break;
                if(j==R){
                    for(int k=0;k<R;k++) work[k]+=alloc[p][k];
                    finish[p] = true;
                    count++;
                    found = true;
                }
            }
        }
        if(!found) break;
    }

    return (count == P);
}

int main(){
    int alloc[P][R], max[P][R];
    int total[R] = {7,2,6};
    int avail[R];

    printf("Enter Allocation Matrix:\n");
    for(int i=0;i<P;i++)
        for(int j=0;j<R;j++)
            scanf("%d",&alloc[i][j]);

    printf("Enter Maximum Matrix:\n");
    for(int i=0;i<P;i++)
        for(int j=0;j<R;j++)
            scanf("%d",&max[i][j]);

    // Display matrices
    displayMatrix(alloc,"Allocation");
    displayMatrix(max,"Maximum");

    // Calculate Available
    for(int j=0;j<R;j++){
        int sum = 0;
        for(int i=0;i<P;i++) sum += alloc[i][j];
        avail[j] = total[j] - sum;
    }

    printf("\nAvailable Array: ");
    for(int j=0;j<R;j++) printf("%d ", avail[j]);
    printf("\n");

    if(isSafe(alloc,max,avail))
        printf("System is in SAFE state. No deadlock.\n");
    else
        printf("System is NOT in safe state. Deadlock possible!\n");

    return 0;
}
