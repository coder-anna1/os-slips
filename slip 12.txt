Q.1 [10] Write a program to illustrate the concept of orphan process ( Using fork() and 
sleep()) .


ans
#include<stdio.h>
#include<unistd.h>
#include<sys/types.h>

int main(){
    pid_t p;
    printf("Before fork\n");
    p = fork();

    if(p == 0){
        sleep(5);
        printf("I am the child. My PID is %d\n", getpid());
        printf("My parent PID is %d\n", getppid());
    }
    else if(p > 0){
        printf("I am the parent. My PID is %d\n", getpid());
        printf("My child PID is %d\n", p);
    }
    else{
        printf("Fork failed.\n");
    }
    return 0;
}


Explanation:

fork() creates a child process.

The child sleeps for 5 seconds (sleep(5)), giving the parent time to finish.

When the child wakes up, its parent will be init (PID 1) or systemd, showing it has become an orphan.

The parent prints its PID and child PID, then exits immediately.

✅ To run this:

gcc orphan.c -o orphan
./orphan



Q.2 Write the simulation program to implement demand paging and show the page 
scheduling and total number of page faults for the following given page reference string. 
Give input n as the number of memory frames. 
Reference String : 12,15,12,18,6,8,11,12,19,12,6,8,12,15,19,8 
Implement OPT


ans
#include <stdio.h>
#define MAX 100

int predict(int referenceString[], int frames[], int refLen, int index, int n) {
    int i, j, farthest = index, pos = -1, found;
    for(i = 0; i < n; i++) {
        found = 0;
        for(j = index; j < refLen; j++) {
            if(frames[i] == referenceString[j]) {
                if(j > farthest) {
                    farthest = j;
                    pos = i;
                }
                found = 1;
                break;
            }
        }
        if(!found)
            return i;
    }
    return (pos == -1) ? 0 : pos;
}

int main() {
    int referenceString[MAX], frames[MAX];
    int refLen, n;
    int i, j, k, pageFaults = 0, found;

    printf("Enter the number of memory frames: ");
    scanf("%d", &n);

    printf("Enter the length of the reference string: ");
    scanf("%d", &refLen);

    printf("Enter the reference string (space-separated):\n");
    for(i = 0; i < refLen; i++) {
        scanf("%d", &referenceString[i]);
    }

    for(i = 0; i < n; i++) {
        frames[i] = -1;
    }

    printf("\nPage Replacement Process (OPT):\n");

    for(i = 0; i < refLen; i++) {
        found = 0;

        for(j = 0; j < n; j++) {
            if(frames[j] == referenceString[i]) {
                found = 1;
                break;
            }
        }

        if(!found) {
            int pos = -1;

            for(j = 0; j < n; j++) {
                if(frames[j] == -1) {
                    pos = j;
                    break;
                }
            }

            if(pos == -1)
                pos = predict(referenceString, frames, refLen, i + 1, n);

            frames[pos] = referenceString[i];
            pageFaults++;
        }

        printf("Step %2d: ", i + 1);
        for(k = 0; k < n; k++) {
            if(frames[k] != -1)
                printf("%d ", frames[k]);
            else
                printf("- ");
        }
        if(found)
            printf(" <- No Page Fault\n");
        else
            printf(" <- Page Fault\n");
    }

    printf("\nTotal Page Faults = %d\n", pageFaults);
    return 0;
}



✅ How to run:

gcc opt_paging.c -o opt_paging
./opt_paging


            or


*Q2. Write the simulation program using FCFS. The arrival time and first CPU bursts of different 
jobs should be input to the system. Assume the fixed I/O waiting time (2 units). The next CPU burst 
should be generated using random  function. The output  should give the Gantt  chart, 
Turnaround     Time     and     Waiting      time      for      each      process      and      average times



ans
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MAX 10
#define IO_WAIT 2

int main() {
    int n, i, j, totalTime = 0;
    int arrival[MAX], cpuBurst[MAX], remaining[MAX], completion[MAX];
    int waiting[MAX], turnaround[MAX];
    int gantt[MAX*10], ganttSize = 0;

    srand(time(0));

    printf("Enter number of processes: ");
    scanf("%d", &n);

    for(i = 0; i < n; i++) {
        printf("Enter arrival time of P%d: ", i+1);
        scanf("%d", &arrival[i]);
        printf("Enter first CPU burst of P%d: ", i+1);
        scanf("%d", &cpuBurst[i]);
        remaining[i] = cpuBurst[i];
    }

    int time = 0;
    int completed = 0;

    while(completed < n) {
        int idx = -1;
        int minArrival = 1e9;
        for(i = 0; i < n; i++) {
            if(remaining[i] > 0 && arrival[i] <= time) {
                if(arrival[i] < minArrival) {
                    minArrival = arrival[i];
                    idx = i;
                }
            }
        }

        if(idx == -1) {
            time++;
            continue;
        }

        gantt[ganttSize++] = idx;
        time += remaining[idx];
        completion[idx] = time;
        remaining[idx] = 0;

        turnaround[idx] = completion[idx] - arrival[idx];
        waiting[idx] = turnaround[idx] - cpuBurst[idx];

        completed++;

        if(completed < n) {
            for(i = 0; i < n; i++) {
                if(remaining[i] > 0 && arrival[i] <= time)
                    arrival[i] += IO_WAIT;
            }
        }

        for(i = 0; i < n; i++) {
            if(remaining[i] > 0 && arrival[i] <= time) {
                remaining[i] = 1 + rand() % 5; 
            }
        }
    }

    printf("\nGantt Chart: ");
    for(i = 0; i < ganttSize; i++) {
        printf("P%d ", gantt[i]+1);
    }

    double avgWT = 0, avgTAT = 0;
    printf("\n\nProcess\tArrival\tCPU Burst\tCompletion\tTAT\tWT\n");
    for(i = 0; i < n; i++) {
        printf("P%d\t%d\t%d\t\t%d\t\t%d\t%d\n", i+1, arrival[i], cpuBurst[i], completion[i], turnaround[i], waiting[i]);
        avgWT += waiting[i];
        avgTAT += turnaround[i];
    }

    printf("\nAverage Turnaround Time = %.2f\n", avgTAT/n);
    printf("Average Waiting Time = %.2f\n", avgWT/n);

    return 0;
}
