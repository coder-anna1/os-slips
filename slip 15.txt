Q.1 Write a program to create a child process using fork().The parent should goto sleep state and 
child process should begin its execution. In the child process, use execl() to execute the “ls” 
command. 


ans
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main() {
pid_t pid;
pid = fork();
if (pid < 0) {
printf("Fork failed.\n");
return 1;
} else if (pid == 0) {
printf("Child process started (PID: %d)\n", getpid());
execl("/bin/ls", "ls", "-l", NULL);
printf("execl failed!\n");
return 1;
} else {
printf("Parent process sleeping (PID: %d)\n", getpid());
sleep(10);
wait(NULL);
printf("Parent process woke up\n");
}
return 0;
}



 
Q.2 Write the simulation program to implement demand paging and show the page scheduling 
and total number of page faults for the following given page reference string. Give input n as the 
number of memory frames. 
Reference String :7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2 
Implement LRU


ans
#include <stdio.h>
#define MAX 100

int findLRU(int time[], int n) {
int i, minimum = time[0], pos = 0;
for(i = 1; i < n; ++i) {
if(time[i] < minimum) {
minimum = time[i];
pos = i;
}
}
return pos;
}

int main() {
int frames[MAX], time[MAX];
int referenceString[MAX];
int n, refLen;
int i, j, pos, pageFaults = 0, count = 0, found;

printf("Enter number of memory frames: ");
scanf("%d", &n);
printf("Enter the length of the reference string: ");
scanf("%d", &refLen);
printf("Enter the reference string:\n");
for(i = 0; i < refLen; i++) {
scanf("%d", &referenceString[i]);
}

for(i = 0; i < n; ++i) {
frames[i] = -1;
time[i] = 0;
}

printf("\nPage Replacement Process (LRU):\n");
for(i = 0; i < refLen; ++i) {
found = 0;

for(j = 0; j < n; ++j) {
if(frames[j] == referenceString[i]) {
count++;
time[j] = count;
found = 1;
break;
}
}

if(!found) {
for(j = 0; j < n; ++j) {
if(frames[j] == -1) {
count++;
pageFaults++;
frames[j] = referenceString[i];
time[j] = count;
found = 1;
break;
}
}
}

if(!found) {
pos = findLRU(time, n);
count++;
pageFaults++;
frames[pos] = referenceString[i];
time[pos] = count;
}

printf("Step %2d: ", i + 1);
for(j = 0; j < n; ++j) {
if(frames[j] != -1)
printf("%d ", frames[j]);
else
printf("- ");
}

if(found)
printf(" <- No Page Fault\n");
else
printf(" <- Page Fault\n");
}

printf("\nTotal Page Faults = %d\n", pageFaults);
return 0;
}



     or


Write the program to simulate Preemptive Shortest Job First (SJF) -scheduling. The arrival time and 
first CPU-burst for different n number of processes should be input to the algorithm. Assume the 
fixed IO waiting time (2 units). The next CPU-burst should be generated randomly. The output should 
give Gantt chart, turnaround time and waiting time for each process. Also find the average waiting 
time and turnaround time. 


ans
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

typedef struct {
    char name[20];
    int at;
    int bt;
    int rt;
    int ct;
    int wt;
    int tat;
    int completed;
} Process;

Process *p;
int n;
int currentTime = 0;
int completedCount = 0;
float totalWT = 0, totalTAT = 0;
const int IO_WAIT = 2;

void accept() {
    printf("Enter the number of processes: ");
    scanf("%d", &n);

    p = (Process*)malloc(sizeof(Process) * n);
    for (int i = 0; i < n; i++) {
        sprintf(p[i].name, "P%d", i + 1);
        printf("\nEnter arrival time for %s: ", p[i].name);
        scanf("%d", &p[i].at);
        printf("Enter CPU burst time for %s: ", p[i].name);
        scanf("%d", &p[i].bt);
        p[i].rt = p[i].bt;
        p[i].wt = 0;
        p[i].tat = 0;
        p[i].ct = 0;
        p[i].completed = 0;
    }
}

int getNextProcess() {
    int idx = -1, minRT = 9999;
    for (int i = 0; i < n; i++) {
        if (!p[i].completed && p[i].at <= currentTime) {
            if (p[i].rt < minRT) {
                minRT = p[i].rt;
                idx = i;
            }
        }
    }
    return idx;
}

void schedule() {
    srand(time(NULL));
    int ganttOrder[1000], ganttTime[1000], orderCount = 0;
    int prevIdx = -1;

    while (completedCount < n) {
        int idx = getNextProcess();
        if (idx == -1) {
            currentTime++;
            continue;
        }

        if (prevIdx != idx) {
            ganttOrder[orderCount] = idx;
            ganttTime[orderCount] = currentTime;
            orderCount++;
        }

        p[idx].rt--;
        currentTime++;

        if (p[idx].rt == 0) {
            p[idx].completed = 1;
            completedCount++;
            p[idx].ct = currentTime;
            p[idx].tat = p[idx].ct - p[idx].at;
            p[idx].wt = p[idx].tat - p[idx].bt;
            totalWT += p[idx].wt;
            totalTAT += p[idx].tat;

            // Simulate I/O wait and next CPU burst
            currentTime += IO_WAIT;
            int nextBurst = (rand() % 5) + 1;
            p[idx].rt = nextBurst;
            p[idx].bt = nextBurst;
            p[idx].completed = 0; // ready for next burst
        }

        prevIdx = idx;
    }

    printf("\nGANTT CHART:\n|");
    for (int i = 0; i < orderCount; i++)
        printf(" %s |", p[ganttOrder[i]].name);
    printf("\n");
    for (int i = 0; i < orderCount; i++)
        printf("%-6d", ganttTime[i]);
    printf("%-6d\n", currentTime);
}

void display() {
    printf("\nPROCESS DETAILS:\n");
    printf("Name\tAT\tBT\tWT\tTAT\tCT\n");
    for (int i = 0; i < n; i++)
        printf("%s\t%d\t%d\t%d\t%d\t%d\n", p[i].name, p[i].at, p[i].bt, p[i].wt, p[i].tat, p[i].ct);

    printf("\nTotal Waiting Time: %.2f", totalWT);
    printf("\nTotal Turnaround Time: %.2f", totalTAT);
    printf("\nAverage Waiting Time: %.2f", totalWT / n);
    printf("\nAverage Turnaround Time: %.2f\n", totalTAT / n);
}

int main() {
    accept();
    schedule();
    display();
    return 0;
}



