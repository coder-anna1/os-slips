Q. 1 Creating a child process using the command exec(). Note down process ids of the parent 
and the child processes, check whether the control is given back to the parent after the child 
process terminates. 

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    pid_t pid = fork();

    if (pid == 0) {
        printf("Child PID: %d, Parent PID: %d\n", getpid(), getppid());
        char *args[] = {"ls", "-l", NULL};
        execvp("ls", args);
        perror("execvp failed");
        exit(1);
    } else if (pid > 0) {
        printf("Parent PID: %d, Child PID: %d\n", getpid(), pid);
        wait(NULL);
        printf("Child process terminated, control returned to parent\n");
    } else {
        perror("fork failed");
    }
    return 0;
}


 
Q.2 Write the simulation program using FCFS. The arrival time and first CPU bursts of different 
jobs should be input to the system. Assume the fixed I/O waiting time (2 units). The next CPU burst 
should be generated using random function. The output should give the Gantt chart, Turnaround    
Time    and    Waiting    time     for     each     process     and     average     times. [20 marks]

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define IO_WAIT 2

void fcfs(int n, int arrival[], int burst[], int process[]) {
    int completion[n], turnaround[n], waiting[n];
    int current_time = 0;
    float total_turnaround = 0, total_waiting = 0;

    printf("\nGantt Chart:\n");
    for (int i = 0; i < n; i++) {
        if (current_time < arrival[i]) current_time = arrival[i];
        printf("P%d(%d-%d) ", process[i], current_time, current_time + burst[i]);
        current_time += burst[i];
        completion[i] = current_time;
        turnaround[i] = completion[i] - arrival[i];
        waiting[i] = turnaround[i] - burst[i];
        total_turnaround += turnaround[i];
        total_waiting += waiting[i];
        current_time += IO_WAIT + (rand() % 10 + 1); // IO wait + next burst
    }

    printf("\n\nProcess\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\n");
    for (int i = 0; i < n; i++) {
        printf("P%d\t%d\t%d\t%d\t\t%d\t\t%d\n",
               process[i], arrival[i], burst[i],
               completion[i], turnaround[i], waiting[i]);
    }

    printf("\nAverage Turnaround Time: %.2f\n", total_turnaround / n);
    printf("Average Waiting Time: %.2f\n", total_waiting / n);
}

int main() {
    int n;
    srand(time(0));

    printf("Enter number of processes: ");
    scanf("%d", &n);

    int arrival[n], burst[n], process[n];
    for (int i = 0; i < n; i++) {
        process[i] = i + 1;
        printf("Enter arrival and burst time for P%d: ", i + 1);
        scanf("%d %d", &arrival[i], &burst[i]);
    }

    fcfs(n, arrival, burst, process);
    return 0;
}


2 Given an initial state of a 8-puzzle problem and final state to be reached 
 
 
Find the most cost-effective path to reach the final state from initial state using A* Algorithm in 
C/Python. [20 marks

import heapq

class Node:
    def __init__(self, state, parent=None, g=0):
        self.state = state
        self.parent = parent
        self.g = g  
        self.h = self.calculate_h()  
        self.f = self.g + self.h     

    def calculate_h(self):
        """Heuristic: number of misplaced tiles."""
        goal_state = [[1, 2, 3], [8, 0, 4], [7, 6, 5]]
        return sum(
            1
            for i in range(3)
            for j in range(3)
            if self.state[i][j] != goal_state[i][j] and self.state[i][j] != 0
        )

    def __lt__(self, other):
        return self.f < other.f


def get_empty_tile_position(state):
    """Find the position of the empty tile (0)."""
    for i in range(3):
        for j in range(3):
            if state[i][j] == 0:
                return i, j


def generate_neighbors(node):
    """Generate all possible states from the current node."""
    neighbors = []
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]  
    empty_i, empty_j = get_empty_tile_position(node.state)

    for di, dj in directions:
        new_i, new_j = empty_i + di, empty_j + dj
        if 0 <= new_i < 3 and 0 <= new_j < 3:  
            new_state = [list(row) for row in node.state]  
            new_state[empty_i][empty_j], new_state[new_i][new_j] = new_state[new_i][new_j], new_state[empty_i][empty_j]
            neighbors.append(Node(new_state, node, node.g + 1))
    return neighbors


def a_star(initial_state):
    """Perform A* search to solve the 8-puzzle."""
    initial_node = Node(initial_state)
    open_set = []
    heapq.heappush(open_set, initial_node)
    g_scores = {tuple(map(tuple, initial_state)): 0}

    while open_set:
        current_node = heapq.heappop(open_set)

        if current_node.h == 0:  
            return reconstruct_path(current_node)

        for neighbor in generate_neighbors(current_node):
            state_tuple = tuple(map(tuple, neighbor.state))
            tentative_g = current_node.g + 1

            if state_tuple not in g_scores or tentative_g < g_scores[state_tuple]:
                g_scores[state_tuple] = tentative_g
                heapq.heappush(open_set, neighbor)

    return None  


def reconstruct_path(node):
    """Reconstruct the path from start to goal."""
    path = []
    while node:
        path.append(node.state)
        node = node.parent
    return path[::-1]


if __name__ == "__main__":
    initial_state = [[2, 8, 3],
                     [1, 6, 4],
                     [7, 0, 5]]

    solution_path = a_star(initial_state)

    if solution_path:
        print("Solution path:")
        for step in solution_path:
            for row in step:
                print(row)
            print()
    else:
        print("No solution found.")